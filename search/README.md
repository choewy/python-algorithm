# 검색 알고리즘

## 1. 개요

어떠한 데이터 집합에서 원하는 값의 원소를 찾아내는 것을 검색 알고리즘이라고 한다.

### 1.1. 검색과 키

주소록을 검색한다고 가정했을 때 다음과 같은 다양한 조건으로 검색할 수 있다.

- 성별이 남자인 사람
- 나이가 20세 이상인 사람
- 이름에 '영' 자가 포함된 사람

위 검색 조건은 모두 어떠한 항목(성별, 나이, 이름)에 주목하고 있는데, 이를 키(key)라고 하며, 대부분 데이터의 일부이다.

- 성별 : key와 일치하도록 지정
- 나이 : key가 포함되도록 지정
- 이름 : key와 가깝도록 지정

### 1.2. 검색의 종류

가장 대표적인 검색 알고리즘으로는 배열 검색, 연결 리스트 검색, 이진 트리 검색이 있다. 본 코드에서는 배열 검색에 대해 다루도록 하며, 배열 검색 알고리즘은 구체적으로 아래와 같은 방법이 있다.

- 선형 검색 : 무작위로 늘어놓은 데이터 집합에서 검색 수행
- 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 집합에서 매우 빠른 검색 수행
- 해시법 : 데이터 추가, 삭제가 빈번하게 발생하는 데이터 집합에서 매우 빠른 검색 수행
  - 체인법 : 같은 해시값 데이터를 연결 리스트로 연결하는 방법
  - 오픈 주소법 : 데이터를 위한 해시값이 출돌할 때 재해시하는 방법

## 2. 선형 검색

선형 검색은 직선 모양(선형)으로 늘어선 배열에서 원하는 키를 검색하는 경우 배열의 맨 앞 부터 스캔하여 해당 키를 찾을 때까지 순차적으로 검색하는 알고리즘으로 데이터 집합이 배열일 때 가장 기본적인 검색 알고리즘이다.

### 2.1. 선형 검색의 종료 조건

선형 검색이 종료되는 조건은 다음과 같다.

- 검색할 값을 찾지 못하는 경우(배열의 맨 끝을 지나간 경우) : 검색 실패
- 검색할 값과 같은 원소를 찾은 경우 : 검색 성공

만약, 배열 `a`에서 검색하고자 하는 값 `key`의 인덱스를 찾기 위한 카운터용 변수를 `i`라고 하였을 때, 선형 검색의 종료 조건은 다음과 같다.

- `if i == len(a)`이 성립하는 경우 : 검색 실패
- `if a[i] == key`이 성립하는 경우 : 검색 성공

### 2.2. 보초법

선형 검색은 반복할 때마다 2가지 종료 조건(검색 실패, 검색 성공)을 확인한다. 이는 단순한 판단이지만, 반복하는 과정에서 계속 실행되므로 종료 조건을 검사하는 비용(cost) 또한 누적되는데, 이를 해결할 수 있는 방법이 보초(sentinel)법이다. 데이터 집합의 가장 마지막에 검색하고자 하는 키를 추가하는데, 이때 저장되는 값을 보초라고 한다. 이를 사용하면 선형 검색의 종료 조건 중 검색 실패에 해당하는 판단을 생략해도 되므로 종료 조건을 검사하는 비용을 줄일 수 있다.

## 3. 이진 검색

이전 검색은 원소가 오름차순 또는 내림차순으로 정렬된 배열에서 보다 효율적으로 검색할 수 있는 알고리즘으로, 쉽게 말하자면 검색 범위를 좁혀가며 원하는 값을 검색하는 알고리즘이다. 즉, 이진 검색은 선형 검색보다 빠르게 검색할 수 있다는 장점이 있으며, 이를 사용하기 위해서는 먼저 배열의 데이터가 정렬되어 있어야 한다.

### 3.1. 이진 검색의 범위를 좁히는 과정

이진 검색은 배열의 첫 부분(`left`), 중간 부분(`center`), 끝 부분(`right`)을 하나의 변수로 두고, 중간 부분을 나누어 키값과 크기를 비교하여 그 범위를 좁혀나가는 방식이다. 만약, 배열 `a`에서 원하는 키 값 `key`를 찾는다고 가정했을 때 이진 검색의 범위를 좀히는 과정은 다음과 같다.

- `a[center] < key`가 성립하는 경우 : 중앙(`center`)에서 오른쪽 한 칸 이동하여 새로운 왼쪽 끝(`left`)으로 지정하고, 검색 범위를 뒤쪽 절반으로 좁힌다.
- `a[center] > key`가 성립하는 경우 : 중앙(`center`)에서 왼쪽 한 칸 이동하여 새로운 오른쪽 끝(`right`)으로 지정하고. 검색 범위를 앞쪽 절반으로 좁힌다.

### 3.2. 이진 검색의 종료 조건

이진 검색 알고리즘의 종료 조건은 아래 조건 중 하나만 성립하면 된다.

- `a[center] == key`가 성립하는 경우 : 검색 성공
- 검색 가능한 범위가 더 이상 없는 경우 : 검색 실패

## 4. 해시법

해시법을 통해 데이터 조회 뿐만 아니라 데이터 추가, 삭제 또한 효율적으로 수행할 수 있다.

### 4.1. 정렬된 배열의 원소 추가와 삭제

일반적으로 정렬된 배열에 새로운 원소를 추가 또는 삭제할 때 많은 비용이 발생한다. 예를 들어, 배열`a`에서 새로운 원소 8을 추가할 때의 과정은 아래와 같다.

```python
a = [1, 3, 5, 7, 9, 12, 14, 16, 18, 20, None, None, None, None, None]
```

- 이진 검색법을 통해 `a[3]`과 `a[4]` 사이에 값이 추가되도록 검색
- `a[3]` 이후의 모든 원소를 한 칸씩 뒤로 이동
- `a[4]`에 8을 대입

이와 같이 원소가 이동하는 데 필요한 복잡도는 O(n)이고, 배열의 크기가 커짐에 따라 그 비용 또한 커질 수 밖에 없다.

### 4.2. 해시법

해시법은 간단한 연산을 통해 "데이터 저장 위치 = 인덱스"를 구하는 방법으로 데이터 검색 뿐만 아니라 데이터 추가, 삭제 또한 효율적으로 수행할 수 있다. 여기서 해시란 원소의 값을 배열의 길이로 나눈 나머지 값으로 데이터에 접근할 때 기준이 된다. 위의 예시에서 데이터 추가 전의 배열을 해시법으로 나타내었을때 해시 테이블은 아래와 같다.

| 원소값(키)               | 1    | 3    | 5    | 7    | 9    | 12   | 14   | 19   | 23   | 30   |
| ------------------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 해시값(15로 나눈 나머지) | 1    | 3    | 5    | 7    | 9    | 12   | 14   | 4    | 8    | 0    |

새로 추가할 원소 8을 15으로 나눈 나머지는 8이므로 그 결과는 아래와 같으며, 원소 값 8 이후의 원소를 뒤로 한 칸씩 이동할 필요가 없다.

| 원소값(키)               | 1    | 3    | 5    | 7    | 8    | 9    | 12   | 14   | 19   | 23   | 30   |
| ------------------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 해시값(15로 나눈 나머지) | 1    | 3    | 5    | 7    | 8    | 9    | 12   | 14   | 4    | 8    | 0    |

이와 같이 원소 값(키)을 해시값으로 변환하는 과정을 해시 함수(hash function)이라고 하고, 해시 테이블에서 만들어진 원소를 버킷(bucket)이라고 한다. 해시 함수는 일반적으로 나머지를 구하는 연산 또는 그 연산을 응용할 때 주로 사용한다.

### 4.3. 해시 충돌

위의 해시 테이블에서 중복된 부분을 찾아볼 수 있는데, 바로 해시값이 8인 8과 18이다. 이와 같이 저장할 버킷이 중복되는 현상을 해시 충돌(collision)이라고 한다. 해시에서는 키와 해시값이 반드시 1:1 대응 관계일 필요는 없기 때문에 해시 충돌이 발생할 수 있다. 이와 같이 해시 충돌이 발생하는 경우 체인법과 오픈 주소법으로 대처할 수 있다.

- 체인법 : 해시값이 같은 원소를 연결 리스트로 관리
- 오픈 주소법 : 빈 버킷을 찾을 때까지 해시를 반복

### 4.4. 체인법

체인법은 해시값이 같은 데이터를 체인 모양의 연결 리스트(linked list)로 연결하는 방법으로, 오픈 해시법(open hashing)이라고도 한다. 단, 여기서 등장한 연결 리스트는 파이썬에서 제공하는 리스트와는 다른 개념이다.

### 4.5. 오픈 주소법

오픈 주소법은 해시 충돌이 발생했을 때 재해시(rehashing)를 수행하여 빈 버킷을 찾는 방법을 말하며 닫힌 해시법(closed hashing)이라고도 한다. 

#### 4.5.1. 원소 추가

예들 들어, 아래 해시표에서 새로운 원소 37를 추가한다고 가정해보자. 

| 원소값(키) | 1    | 3    | 5    | 7    | 8    | 9    | 12   | 14   | 19   | 23   | 30   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 해시값     | 1    | 3    | 5    | 7    | 8    | 9    | 12   | 14   | 4    | 8    | 0    |

그 결과 이미 해시값 7이 존재하기 때문에 재해시를 수행하여야 한다. 이때 재해시를 위한 함수는 자유롭게 정할 수 있는데, 예시에서는 키값에 1을 더하여 15로 나눈 나머지를 사용하였다. 37을 추가하기 위해 수행한 과정은 아래와 같으며, 이와 같이 빈 버킷을 발견할 때까지 재해시를 반복하므로 오픈 주소법을 선형 탐사법(linear probing)이라고도 한다.

- 최초 해시 →  37 % 15 = 7 : 해시 충돌
- 1차 재해시 → (37 + 1) % 15 = 8 : 해시 충돌
- 2차 재해시 → (38 + 1) % 15 = 9 : 해시 충돌
- 3차 재해시 → (39 + 1) % 15 = 10 : 입력 성공

#### 4.5.2. 원소 삭제

예를 들어, 아래 해시표에서 원소 5를 삭제한다고 가정해보자.

| 해시값     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 원소값(키) | 30   | 1    | None | 3    | 19   | 5    | 20   | 7    | 8    | 9    | 10   | 11   |

이때 단순하게 인덱스가 5인 버킷을 비워주기만 하면 안 되는데, 그 이유는 해시값이 같은 키값인 20을 검색할 때 해시값이 5인 데이터는 존재하지 않는다고 착각하여 검색에 실패하기 때문이다. 이와 같은 오류를 방지하기 위하여 각 버킷에 아래의 속성을 부여한다.

- 데이터가 저장되어 있음 : 원소값
- 비어 있음 : -
- 삭제 완료 : ▲

| 해시값     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 원소값(키) | 30   | 1    | -    | 3    | 19   | ▲    | 20   | 7    | 8    | 9    | 10   | 11   |

이렇게 버킷에 삭제 완료 속성을 부여하여 해시값이 같은 데이터는 다른 버킷에 있다는 정보를 알려준다.

#### 4.5.3. 원소 검색

위의 예시에 이어서 키값 20을 검색해보았을 때 그 과정은 아래와 같다.

- 해시값이 5인 버킷은 삭제 완료 상태이므로 재해시
- 해시값이 6인 버킷의 키값이 20이므로 검색 완료